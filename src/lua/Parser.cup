package lua;
import java.io.*;
import java.util.*;
import java_cup.runtime.*;
import lua.Lexer;

parser code {:

    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }

:};

terminal String EQUAL, DO, END, WHILE, REPEAT, UNTIL, IF, THEN, ELSEIF, ELSE, FOR, COMMA, 
IN, FUNCTION, LOCAL, RETURN, BREAK, DOT, COLON, NIL, FALSE, TRUE, THREE_DOTS, L_PARENTHESIS,
 R_PARENTHESIS, L_BRACES, R_BRACES, L_BRACKETS, R_BRACKETS, PLUS, MINUS, TIMES, DIV, EXP,
  MOD, TWO_DOTS, SMALLER_THAN, SMALLER_THAN_OR_EQUAL, GREATER_THAN,
   GREATER_THAN_OR_EQUAL,EQUAL_EQUAL, APROX, AND, OR, NOT, HASHTAG, STRING, NAME, SEMICOLON;
terminal Integer INTEGER, FLOAT;

non terminal String chunck, stat, laststat, varlist, explist, functioncall, block, exp, namelist, funcname, funcbody, var, prefixexp, function, tableconstructor, binop, unop, args, parlist, fieldlist, field, fieldesp, 
a, c, h, j, l, m, q;

precedence left OR;
precedence left AND;
precedence left SMALLER_THAN, GREATER_THAN, SMALLER_THAN_OR_EQUAL, GREATER_THAN_OR_EQUAL, APROX, EQUAL_EQUAL;
precedence right COLON ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
/*precedence left UOP;*/
precedence right EXP;

start with chunck;


chunck ::= /* empty */
        |laststat SEMICOLON
        |laststat
        |a
        |a laststat SEMICOLON
        |a laststat;
a      ::= /* empty */ | a stat SEMICOLON | a stat;

block ::= chunck;

stat ::= varlist EQUAL explist
        |functioncall
        |DO block END
        |WHILE exp DO block END
        |REPEAT block UNTIL exp
        |IF exp THEN block c
        |IF exp THEN block c ELSE block END
        |FOR NAME EQUAL exp COLON exp DO block END
        |FOR NAME EQUAL exp COLON exp COLON exp DO block END
        |FOR namelist IN explist DO block END
        |FUNCTION funcname funcbody
        |LOCAL FUNCTION NAME funcbody
        |LOCAL namelist
        |LOCAL namelist EQUAL explist;
c      ::= /* empty */ | c ELSEIF exp THEN block;

laststat ::= RETURN
        |RETURN explist
        |BREAK;

funcname ::= NAME h
            |NAME h COLON NAME;
h      ::= /* empty */ | h DOT NAME;

varlist  ::= var j;
j      ::= /* empty */ | j COMMA var;

var    ::= NAME
        |prefixexp
        |prefixexp exp
        |prefixexp DOT NAME;

namelist ::= NAME l;
l      ::= /* empty */ | l COMMA NAME;

explist  ::= m exp;
m        ::= /* empty */ | m exp COMMA;

exp ::= NIL
        |FALSE
        |TRUE
        |INTEGER
        |FLOAT
        |STRING
        |THREE_DOTS
        |function
        |prefixexp
        |tableconstructor
        |exp binop exp
        |unop exp;

prefixexp ::= var
            |functioncall
            |L_PARENTHESIS exp R_PARENTHESIS;

functioncall ::= prefixexp args
                |prefixexp COLON NAME args;

args ::= L_PARENTHESIS explist R_PARENTHESIS
        |L_PARENTHESIS R_PARENTHESIS
        |tableconstructor
        |STRING;

function ::= FUNCTION funcbody;

parlist ::= namelist
        |namelist COMMA THREE_DOTS
        |THREE_DOTS;

tableconstructor ::= L_BRACKETS fieldesp R_BRACKETS
        |L_BRACKETS R_BRACKETS;

fieldlist   ::= field q fieldesp
        |field q;
q       ::= /* empty */ | q fieldesp field;

field ::= L_BRACES exp R_BRACES EQUAL exp
        |NAME EQUAL exp
        |exp;

fieldesp ::= COMMA
        |SEMICOLON;

binop ::= PLUS
        |MINUS
        |TIMES
        |DIV
        |EXP
        |MOD
        |TWO_DOTS
        |GREATER_THAN
        |GREATER_THAN_OR_EQUAL
        |SMALLER_THAN
        |SMALLER_THAN_OR_EQUAL
        |EQUAL_EQUAL
        |APROX
        |AND
        |OR;

unop ::= MINUS
        |NOT
        |HASHTAG;