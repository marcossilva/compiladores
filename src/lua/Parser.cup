package lua;
import java.io.*;
import java.util.*;
import java_cup.runtime.*;
import lua.Lexer;

parser code {:

    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }

:};

terminal String EQUAL, DO, END, WHILE, REPEAT, UNTIL, IF, THEN, ELSEIF, ELSE, FOR, COMMA, 
IN, FUNCTION, LOCAL, RETURN, BREAK, DOT, COLON, NIL, FALSE, TRUE, THREE_DOTS, L_PARENTHESIS,
 R_PARENTHESIS, L_BRACES, R_BRACES, L_BRACKETS, R_BRACKETS, PLUS, MINUS, TIMES, DIV, EXP,
  MOD, TWO_DOTS, SMALLER_THAN, SMALLER_THAN_OR_EQUAL, GREATER_THAN,
   GREATER_THAN_OR_EQUAL,EQUAL_EQUAL, APROX, AND, OR, NOT, HASHTAG, STRING, NAME, SEMICOLON, UOP;
terminal Integer INTEGER, FLOAT;

non terminal String chunck, stat, laststat, varlist, explist, functioncall, block, exp, namelist, funcname, funcbody, var, prefixexp, function, tableconstructor, binop, unop, args, parlist, fieldlist, field, fieldesp, 
c, h, j, l, m, q;

precedence left OR;
precedence left AND;
precedence left SMALLER_THAN, GREATER_THAN, SMALLER_THAN_OR_EQUAL, GREATER_THAN_OR_EQUAL, APROX, EQUAL_EQUAL;
precedence right TWO_DOTS ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left UOP;
precedence right EXP;

start with chunck;


chunck ::= /* empty */
        |laststat SEMICOLON
        |laststat
        |stat chunck
        |stat SEMICOLON chunck;

block ::= chunck;

stat ::= varlist EQUAL explist
        |functioncall
        |DO block END
        |WHILE exp DO block END
        |REPEAT block UNTIL exp
        |IF exp THEN block END
        |IF exp THEN block c END
        |IF exp THEN block ELSE block END
        |IF exp THEN block c ELSE block END
        |FOR NAME EQUAL exp COLON exp DO block END
        |FOR NAME EQUAL exp COLON exp COLON exp DO block END
        |FOR namelist IN explist DO block END
        |FUNCTION funcname funcbody
        |LOCAL FUNCTION NAME funcbody
        |LOCAL namelist
        |LOCAL namelist EQUAL explist;
c      ::= c ELSEIF exp THEN block | ELSEIF exp THEN block;

laststat ::= RETURN
        |RETURN explist
        |BREAK;

funcname ::= NAME
            |NAME h
            |NAME h COLON NAME;
h      ::= DOT NAME | h DOT NAME;

varlist  ::= var j
            |var;
j      ::= COMMA var | j COMMA var;

var    ::= NAME
        |prefixexp L_BRACES exp R_BRACES
        |prefixexp DOT NAME;

namelist ::= NAME l
        |NAME;
l      ::= COMMA NAME | l COMMA NAME;

explist  ::= m exp
        | exp;
m        ::= exp COMMA | m exp COMMA;

exp ::= NIL
        |FALSE
        |TRUE
        |INTEGER
        |FLOAT
        |STRING
        |THREE_DOTS
        |function
        |prefixexp
        |tableconstructor
        |exp binop exp
        |unop exp %prec UOP;

prefixexp ::= var
            |functioncall /*conflito*/
            |L_PARENTHESIS exp R_PARENTHESIS;

functioncall ::= prefixexp args
                |prefixexp COLON NAME args;

args ::= L_PARENTHESIS explist R_PARENTHESIS
        |L_PARENTHESIS R_PARENTHESIS
        |tableconstructor
        |STRING;

function ::= FUNCTION funcbody;

parlist ::= namelist
        |namelist COMMA THREE_DOTS
        |THREE_DOTS;

tableconstructor ::= L_BRACKETS fieldesp R_BRACKETS
        |L_BRACKETS R_BRACKETS;

fieldlist   ::= field q fieldesp
        |field fieldesp
        |field q
        |field;
q       ::= fieldesp field | q fieldesp field;

field ::= L_BRACES exp R_BRACES EQUAL exp
        |NAME EQUAL exp
        |exp;

fieldesp ::= COMMA
        |SEMICOLON;

binop ::= PLUS
        |MINUS
        |TIMES
        |DIV
        |EXP
        |MOD
        |TWO_DOTS
        |GREATER_THAN
        |GREATER_THAN_OR_EQUAL
        |SMALLER_THAN
        |SMALLER_THAN_OR_EQUAL
        |EQUAL_EQUAL
        |APROX
        |AND
        |OR;

unop ::= MINUS
        |NOT
        |HASHTAG;